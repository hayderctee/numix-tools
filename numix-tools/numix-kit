#!/bin/bash
# Script to generate icons from SVG templates
#
# Copyright (c) 2014  Numix Project
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# DIRECTORY STRUCTURE
#
# The script understands the following directory structure.
# It will take color information and file name from the symbols
#
# input/
#     templates/
#         square/
#             template.meta
#             shadow.svg
#             background.svg
#             underlay.svg
#             overlay.svg
#             blur.svg
#             clip.svg
#     symbols/
#         file-manager.svg
#         text-editor.svg
#         web-browser.svg
# output/
#     svg/
#     png/
#
# COLOR INFORMATION
#
# The color information should be written in the following format
# Only HEX color code is recognized
#
# <!-- color: #d64937 -->
# And for unknown reason - Αποφις!

while [[ $# -gt 0 ]]; do
    case "$1" in
        -d|--dir)
            basedir="$2"
            shift;;
        -t|--template)
            template="$2"
            shift;;
        -p|--png)
            makepng="true";;
        -s|--store)
            optimize="false";;
        -h|--help)
            args=( "-d, --dir <directory>" "-t, --template" "-p, --png" "-s, --store" "-h, --help" )
            desc=( "specify base directory" "specify template directory to use" "generate PNG files" "don't optimize icons" "show this help message and exit" )
            printf "Usage:\tgen-icons [options...]\n\n"
            for ((i=0; i < ${#args[@]}; i++)); do
                printf "\t%-30s%-s\n" "${args[i]}" "${desc[i]}"
            done
            exit;;
        -?|--*)
            printf "Unrecognized option '$1'. Try '--help' for all available options.\n"
            exit;;
        -*)
            args="$1"
            shift
            set -- $(printf "$args" | cut -c 2- | sed 's/./-& /g') "$@"
            continue;;
        *)
            break;;
    esac
    shift
done

[[ "$basedir" = "" ]] && basedir="."
[[ "$makepng" = "" ]] && makepng="false"
[[ "$optimize" = "" ]] && optimize="true"

indir="$basedir/input"
outdir="$basedir/output"
symbolsdir="$indir/symbols"

trap exit INT

show_info() {
echo -e "\033[0;34m$@\033[0m"
return 0
}

show_success() {
echo -e "\033[0;32m$@\033[0m"
return 0
}

show_warn() {
echo -e "\033[0;33m$@\033[0m" 1>&2
return 2
}

show_err() {
echo -e "\033[0;31m$@\033[0m" 1>&2
return 1
}

make_png() {
rm -f "$outdir/$template/png/${icon/svg/png}"

which rsvg-convert > /dev/null 2>&1
if [[ $? -eq 0 ]]; then
    rsvg-convert "$outdir/$template/svg/$icon" -o "$outdir/$template/png/${icon/svg/png}" > /dev/null 2>&1
else
    show_warn "rsvg-convert not installed."
fi

if [[ -f "$outdir/$template/png/${icon/svg/png}" ]]; then
    if [[ "$optimize" = "true" ]]; then
        which optipng > /dev/null 2>&1
        if [[ $? -eq 0 ]]; then
            optipng -strip all -o7 -zm1-9 "$outdir/$template/png/${icon/svg/png}" > /dev/null 2>&1
        else
            show_warn "optipng not installed."
        fi
    fi

    show_success "Successfully wrote ${icon/svg/png}."
else
    show_err "Failed to write ${icon/svg/png}."
fi
}

make_svg() {
layers=$(echo "$1" | sed -e "s/\+/ /g")
svg="<svg ${viewbox}>"

for layer in $layers; do
    if [[ ! ${!layer} = "" ]]; then
        svg+="<g id=\"${layer}\">${!layer}</g>"
    fi
done

svg+="</svg>"

rm -f "$outdir/$template/svg/$icon"
echo "$svg" > "$outdir/$template/svg/$icon"

if [[ -f "$outdir/$template/svg/$icon" && $(grep "<svg\|</svg>" "$outdir/$template/svg/$icon") ]]; then
    if [[ "$optimize" = "true" ]]; then
        which svgcleaner-cli > /dev/null 2>&1
        if [[ $? -eq 0 ]]; then
            svgcleaner-cli "$outdir/$template/svg/$icon" "$outdir/$template/svg/$icon" --colors-to-rrggbb --convert-to-relative --compact-output --create-viewbox --equal-elts-to-use --merge-gradients --remove-ai-atts --remove-ai-elts --remove-corel-atts --remove-corel-elts --remove-duplicated-defs --remove-empty-containers --remove-fill-props --remove-inkscape-atts --remove-inkscape-elts --remove-invisible-elts --remove-metadata-elts --remove-msvisio-atts --remove-msvisio-elts --remove-nonsvg-elts --remove-notappl-atts --remove-outside-elts --remove-proc-instr --remove-prolog --remove-sketch-atts --remove-sketch-elts --remove-sodipodi-atts --remove-sodipodi-elts --remove-stroke-props --remove-unreferenced-ids --remove-unused-defs --remove-unused-xlinks --remove-version --rrggbb-to-rgb > /dev/null 2>&1
        else
            show_warn "svgcleaner-cli not installed."
        fi
    fi

    show_success "Successfully wrote $icon."
else
    show_err "Failed to write $icon."
fi
}

strip_tags() {
cat "$1" | tr "\n" " " | sed -e "s/<\/\?svg[^>]*>//g" -e "s/<[?]\?xml[^>]*>//g"
}

re_color() {
data="$1"
color="$2"

if [[ $(echo "$data" | grep "fill[:=]") ]]; then
    data=$(echo "$data" | sed -e "s/fill=\"/style=\"fill:/g" -e "s/fill:[^;\"]*/fill:${color}/g")
else
    oldtag=$(echo "$data" | grep -o "<.*" | grep -v "<[\!\?].+" | head -n 1 | sed -e 's/[[\.+^$/]/\\&/g')
    newtag=$(echo "$oldtag" | sed -e "s/$/ style=\"fill:${color}\"/")
    data=$(echo "$data" | sed -e "0,/$oldtag/s//$newtag/")
fi

echo "$data"
}

add_attr() {
data="$1"
attr="$2"
type=$(echo "$attr" | cut -f1 -d"=")

if [[ "$type" = "fill" ]]; then
    prop=$(echo "$attr" | cut -f2 -d"\"")

    if [[ "$attr" =~ ^.+=\".+\[.+\]\"$ ]]; then
        value=$(read_props "$prop")
    else
        value="$prop"
    fi

    [[ "$value" = "" ]] && show_warn "Cannot find $prop value"

    data=$(re_color "$data" "${value:0:7}")
elif [[ "$type" = "clip-path" || "$type" = "filter" ]]; then
    case "$type" in
        "clip-path")
            tagname="clipPath";;
        "filter")
            tagname="filter";;
    esac

    id=$(date +%N)
    url=$(echo "$attr" | cut -f2 -d"\"" | cut -f1 -d".")

    if [[ ! "${!url}" = "" ]]; then
        data="<defs><${tagname} id=\"${tagname}-${id}\">${!url}</${tagname}></defs><g ${type}=\"url(#${tagname}-${id})\">${data}</g>"
    else
        show_warn "$type is empty or doesn't exist."
    fi
else
    data="<g ${attr}>${data}</g>"
fi

echo "$data"
}

get_viewbox() {
file=$(find "$templatedir" -type f -name "*.svg" | xargs ls -1S | head -n 1)
viewbox=$(cat "$file" | grep -o 'viewBox="[^"]*"')

if [[ "$viewbox" = "" ]]; then
    width=$(cat "$file" | tr "\n" " " | grep -o "<svg[^>]*>" | grep -o 'width="[^"]*"' | sed -e "s/width=//g" -e "s/\"//g")
    height=$(cat "$file" | tr "\n" " " | grep -o "<svg[^>]*>" | grep -o 'height="[^"]*"' | sed -e "s/height=//g" -e "s/\"//g")
    viewbox="viewBox=\"0 0 $width $height\""
fi

[[ "$viewbox" = "" || "$viewbox" = "0 0    " ]] && show_warn "Failed to determine viewBox."
}

read_props() {
data=$(echo "$1" | sed -e "s/\[/_/" -e "s/\]//")
prop=$(echo "$data" | cut -f1 -d"_")
name=$(echo "$data" | cut -f2 -d"_")
value=$(echo "${!name}" | grep -o "<\!-- ${prop}: .* -->" | sed -e "s/<\!-- ${prop}: //g" -e "s/ -->//g")

if [[ ! "$value" = "" ]]; then
    echo "$value"
else
    show_warn "Property $prop not found."
fi
}

read_files() {
while read svg; do
    name=${svg##*/}
    var=${name%.svg}

    if [[ $(grep "<svg\|</svg>" "$svg") ]]; then
        export $var="$(strip_tags $svg)"
    else
        show_warn "$var doesn't seem to be a valid SVG file."
    fi

    [[ $(grep "data:image" "$svg") ]] && show_warn "$svg contains raster image."
done < <(find "$templatedir/" -name '*.svg' | sort -u)
}

read_commands() {
echo "$1" | while read line; do
    data=""
    command=""
    for command in ${line[@]}; do
        if [[ "$command" =~ ^[a-z]+$ ]]; then
            data="$command"
        elif [[ "$command" =~ ^[a-z\-]+=\".*\"$ ]]; then
            declare $data="$(add_attr "${!data}" "$command")"
        elif [[ "$command" =~ ^\%[a-z]+$ ]]; then
            declare ${command#%}="${!data}"
            data=${command#%}
        elif [[ "$command" =~ ^[a-z]+\+.*[a-z]+$ ]]; then
            make_svg "$command"

            [[ "$makepng" = "true" ]] && make_png
        else
            show_warn "Unrecognized command $command."
        fi
    done
done
}

gen_icons() {
if [[ ! -d "$templatedir" ]]; then
    show_err "Template directory not found."
    exit 1
fi

[[ -d "$outdir/$template/svg" ]] || mkdir -p "$outdir/$template/svg"
[[ -d "$outdir/$template/png" ]] || [[ "$makepng" = "true" ]] && mkdir -p "$outdir/$template/png"

if [[ -f "$templatefile" ]]; then
    templatedata=$(cat "$templatefile" | sed -e "s/ //g" -e "s/->/ /g")
else
    show_err "No template file found in $templatefile."
    exit 1
fi

if [[ "$templatedata" = "" ]]; then
    show_err "Template file is empty."
    exit 1
fi

show_info "Found template in $templatedir"

read_files
get_viewbox

while read file; do
    icon=${file##*/}
    symbol=$(strip_tags "$file")
    read_commands "$templatedata"
done < <(find "$symbolsdir/" -name '*.svg' | sort -u)
}

get_template() {
if [[ ! -d "$indir" || ! -d "$symbolsdir" ]]; then
    show_err "Directory structure is not set up."
    exit 1
fi

if [[ "$template" = "" ]]; then
    while read dir; do
        if [[ -f "$dir/template.meta" ]]; then
            template="${dir##*/}"
            templatedir="$dir"
            templatefile="$dir/template.meta"
            gen_icons
        fi
    done < <(find "$indir/templates" -maxdepth 1 -type d)
else
    templatedir="$indir/templates/$template"
    templatefile="$templatedir/template.meta"
    gen_icons
fi
}

get_template
